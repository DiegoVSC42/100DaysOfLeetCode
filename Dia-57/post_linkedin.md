üöÄ Dia 57/100: #100DaysOfLeetCode - Verificando Sub√°rvores com recurs√£o e reaproveitamento de l√≥gica

Hoje resolvi um exerc√≠cio que me permitiu reutilizar uma solu√ß√£o feita no dia 54. Naquele desafio, implementei uma verifica√ß√£o para saber se duas √°rvores bin√°rias eram iguais. Agora, adaptei essa l√≥gica para verificar se uma √°rvore est√° contida dentro de outra.

üí° Minha Solu√ß√£o:

A estrat√©gia foi percorrer a √°rvore principal recursivamente e, em cada n√≥, comparar a estrutura dali com a sub√°rvore alvo. Isso foi feito com a mesma fun√ß√£o que compara duas √°rvores, o que mostrou como √© valioso escrever fun√ß√µes reutiliz√°veis em problemas mais complexos. A l√≥gica de verificar se uma √°rvore √© igual √† outra foi aplicada em cada subparte da √°rvore principal, garantindo assim uma solu√ß√£o completa e eficaz.

üåü Reflex√£o do dia:

Reaproveitar solu√ß√µes anteriores torna o processo mais √°gil e refor√ßa o entendimento das estruturas de dados. Ver como uma fun√ß√£o j√° constru√≠da se encaixa perfeitamente em um novo contexto traz seguran√ßa no que est√° sendo aprendido e praticado.

üìå Links:
Desafio: https://leetcode.com/problems/subtree-of-another-tree/description/
Minha Solu√ß√£o: https://github.com/DiegoVSC42/100DaysOfLeetCode/blob/main/Dia-57/Solution.java

#Java #BinaryTree #Recursao #Reutilizacao #DataStructures #100DaysOfLeetCode