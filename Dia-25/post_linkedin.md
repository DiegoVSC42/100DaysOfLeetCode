🚀 Dia 25/100: #100DaysOfLeetCode – Três Novos Desafios com Arrays!

Hoje resolvi três problemas desafiadores, todos focados em manipulação de arrays. Foi um dia intenso que me permitiu explorar desde estruturas de dados básicas até algoritmos sofisticados.

💡 Sobre os Problemas:

1️⃣ Contains Duplicate:
Identificar se um array contém elementos duplicados. Minha primeira versão usou HashMap, mas depois otimizei para HashSet, percebendo que só precisava verificar a existência dos elementos, não suas contagens.

2️⃣ Product of Array Except Self:
Calcular um novo array onde cada elemento é o produto de todos os outros elementos do array original, sem usar divisão. Utilizei dois arrays auxiliares para armazenar produtos acumulados da esquerda e direita.

3️⃣ Maximum Subarray:
Encontrar a soma máxima possível de qualquer subarray contíguo usando o Algoritmo de Kadane, que mantém registro do máximo local e global enquanto percorre o array.

🌟 Reflexão do Dia 25:

1️⃣ Otimização de Estruturas: Aprendi que escolher a estrutura certa (HashSet vs HashMap) pode melhorar significativamente o desempenho.
2️⃣ Solução Criativa: No Product of Array, descobri como pré-calcular produtos pode resolver problemas aparentemente complexos.
3️⃣ Algoritmo Elegante: O Algoritmo de Kadane me mostrou como soluções simples podem ser extremamente eficazes para problemas específicos.

📌 Para quem se identifica:

Se você também está estudando estruturas de dados ou algoritmos para manipulação de arrays, vamos trocar ideias e experiências!

👉 Acompanhe a jornada:

Quer ver minhas implementações completas ou discutir outras abordagens? Comente abaixo!

Links para os desafios:

- Contains Duplicate: https://leetcode.com/problems/contains-duplicate/
- Product of Array: https://leetcode.com/problems/product-of-array-except-self/
- Maximum Subarray: https://leetcode.com/problems/maximum-subarray/

Link para o código: https://github.com/DiegoVSC42/100DaysOfLeetCode/tree/main/Dia-25

#100DaysOfLeetCode #Arrays #Algorithms #Optimization #Java
