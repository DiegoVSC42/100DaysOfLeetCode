ğŸš€ Dia 81/100: #100DaysOfLeetCode â€“ ProgramaÃ§Ã£o DinÃ¢mica e o clÃ¡ssico Coin Change

Hoje o desafio foi bastante complexo e resolvi fazer ele da forma como fazia na faculdade. Lembro que precisei fazer uma tabela dessas em uma das provas de AnÃ¡lise de Algoritmos, minha matÃ©ria favorita. Entender a lÃ³gica por trÃ¡s do problema foi bastante tranquilo, pois jÃ¡ tinha estudado sobre o problema do mochileiro, porÃ©m nunca tinha implementado em cÃ³digo de fato. O mais complicado foi lidar com os edge cases, tendo que criar a tabela com todos os valores infinitos.

ğŸŒŸ Minha SoluÃ§Ã£o:

Usei uma abordagem clÃ¡ssica de programaÃ§Ã£o dinÃ¢mica, montando uma matriz para armazenar as subsoluÃ§Ãµes. A ideia foi trabalhar com todos os casos possÃ­veis, garantindo que a soluÃ§Ã£o fosse completa mesmo com entradas complexas.

ğŸ’¡ ReflexÃ£o do dia:

Gostei bastante de relembrar conceitos de anÃ¡lise de algoritmos e aplicar diretamente na resoluÃ§Ã£o de problemas reais. Percebi que, alÃ©m da lÃ³gica, Ã© importante ter bastante atenÃ§Ã£o aos detalhes na hora de tratar os casos extremos.

ğŸ“š DocumentaÃ§Ã£o:
Arrays: https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html

ğŸ“Œ Links:
Desafio: https://leetcode.com/problems/coin-change/
Minha SoluÃ§Ã£o: https://github.com/DiegoVSC42/100DaysOfLeetCode/blob/main/Dia-81/Solution.java

#Java #DynamicProgramming #100DaysOfLeetCode
