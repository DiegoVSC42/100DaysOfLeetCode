ğŸš€ Dia 82/100: #100DaysOfLeetCode â€“ ProgramaÃ§Ã£o DinÃ¢mica e Knapsack

Hoje o desafio foi bastante complexo, resolvi fazer outro exercÃ­cio utilizando a tÃ©cnica de knapsack. Foi difÃ­cil entender a lÃ³gica do problema, mas depois de compreender e bolar uma estratÃ©gia de como criar a lista com os resultados, ficou mais tranquilo. O melhor de tudo foi que, mesmo tendo laÃ§os for dentro de for, o programa teve um runtime bastante satisfatÃ³rio graÃ§as Ã s quebras de laÃ§os que os finalizam o mais rÃ¡pido possÃ­vel.

ğŸŒŸ Minha SoluÃ§Ã£o:

Utilizei programaÃ§Ã£o dinÃ¢mica com um array booleano para armazenar os estados possÃ­veis de soma. A abordagem foi tentar equilibrar o peso das pedras da melhor forma possÃ­vel, minimizando a diferenÃ§a entre os dois grupos.

ğŸ’¡ ReflexÃ£o do dia:

Mais um dia reforÃ§ando a importÃ¢ncia da programaÃ§Ã£o dinÃ¢mica. A cada exercÃ­cio percebo que o mais importante Ã© pensar cuidadosamente na estratÃ©gia antes de sair codando. Otimizar a execuÃ§Ã£o dos laÃ§os tambÃ©m foi fundamental para um bom desempenho.

ğŸ“š DocumentaÃ§Ã£o:
Arrays: https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html
Math: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

ğŸ“Œ Links:
Desafio: https://leetcode.com/problems/last-stone-weight-ii/
Minha SoluÃ§Ã£o: https://github.com/DiegoVSC42/100DaysOfLeetCode/blob/main/Dia-82/Solution.java

#Java #DynamicProgramming #Knapsack #100DaysOfLeetCode
