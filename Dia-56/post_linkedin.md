üöÄ Dia 56/100: #100DaysOfLeetCode - Invertendo uma √Årvore Bin√°ria com DFS

Hoje resolvi um exerc√≠cio cl√°ssico: inverter uma √°rvore bin√°ria. √Ä primeira vista parecia algo complicado, mas decidi aplicar uma l√≥gica semelhante √† que uso para trocar posi√ß√µes em arrays, e a abordagem funcionou perfeitamente.

üí° Minha Solu√ß√£o:

Implementei uma fun√ß√£o recursiva simples utilizando DFS. A ideia foi percorrer a √°rvore e, a cada n√≥, inverter os filhos esquerdo e direito. O maior desafio foi confiar que essa l√≥gica recursiva simples daria conta de toda a √°rvore. A pr√°tica mostrou que √†s vezes as solu√ß√µes mais diretas s√£o tamb√©m as mais eficazes.

‚≠ê Reflex√£o do dia:

Foi um bom exerc√≠cio para refor√ßar o pensamento recursivo. O que parecia inicialmente complicado se mostrou bem mais intuitivo quando comparei com a troca de vari√°veis. √â interessante como ideias b√°sicas podem escalar bem quando aplicadas a estruturas mais complexas como √°rvores.

üìå Links:
Desafio: https://leetcode.com/problems/invert-binary-tree/submissions/1625498899/
Minha Solu√ß√£o: https://github.com/DiegoVSC42/100DaysOfLeetCode/blob/main/Dia-56/Solution.java

#Java #BinaryTree #DFS #Recursao #DataStructures #100DaysOfLeetCode