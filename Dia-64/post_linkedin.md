游 Dia 64/100: #100DaysOfLeetCode - Algoritmo de Dijkstra em a칞칚o

Hoje estudei o algoritmo de Dijkstra e resolvi aplic치-lo em um desafio pr치tico. Foi minha primeira vez utilizando a PriorityQueue em Java, e ela se mostrou essencial para otimizar a escolha dos pr칩ximos n칩s com menor custo. Aprendi bastante sobre como estruturar o grafo com Map e aplicar uma l칩gica eficiente para encontrar os caminhos mais curtos.

游 Minha Solu칞칚o:
Implementei o algoritmo de Dijkstra utilizando Map para representar a tabela de adjac칡ncia e PriorityQueue como uma min-heap para gerenciar os n칩s com base nas dist칙ncias m칤nimas calculadas.

游눠 Reflex칚o do dia:
Foi um excelente exerc칤cio para consolidar os conceitos de grafos ponderados e caminhos m칤nimos. O v칤deo do Abdul Bari sobre o algoritmo me ajudou bastante e recomendo para quem quer entender a fundo: https://www.youtube.com/watch?v=XB4MIexjvY0

游닄 Documenta칞칚o:
Map: https://docs.oracle.com/javase/8/docs/api/java/util/Map.html
PriorityQueue: https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html

游늷 Links:
Desafio: https://leetcode.com/problems/network-delay-time/
Minha Solu칞칚o: https://github.com/DiegoVSC42/100DaysOfLeetCode/blob/main/Dia-64/Solution.java

#Java #Graph #Dijkstra #PriorityQueue #100DaysOfLeetCode
